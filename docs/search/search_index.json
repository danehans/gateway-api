{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This is the documentation for the evolution of service-related APIs for Kubernetes. This project is part of the Kubernetes project working under SIG-NETWORK . Gateway API Gateway is an API for a common portable declarative description of load-balancing infrastructure for Kubernetes. If you are a user: User guide (how to use the API) Cookbook for common tasks If you are a developer: How to build and test How to contribute, meetings, design docs For everyone: Concepts and detailed descriptions API specification Feedback, use cases, user stories, bug reports","title":"Introduction"},{"location":"#introduction","text":"This is the documentation for the evolution of service-related APIs for Kubernetes. This project is part of the Kubernetes project working under SIG-NETWORK .","title":"Introduction"},{"location":"#gateway-api","text":"Gateway is an API for a common portable declarative description of load-balancing infrastructure for Kubernetes. If you are a user: User guide (how to use the API) Cookbook for common tasks If you are a developer: How to build and test How to contribute, meetings, design docs For everyone: Concepts and detailed descriptions API specification Feedback, use cases, user stories, bug reports","title":"Gateway API"},{"location":"community/","text":"How to contribute This page contains links to all of the meeting notes, design docs and related discussions around the APIs. Communications Major discussions and notifications will be sent on the SIG-NETWORK mailing list . We also have a Slack channel (sig-network-service-apis) on k8s.io for day-to-day questions, discussions. Meetings Meetings discussing the evolution of the service APIs will alternate times to accommodate participants from various time zones: Thursday 10:30 AM Pacific ( calendar link ) Thursday 4:30 (16:30) PM Pacific ( calendar link ) Video conferencing Meeting link Topic: [SIG-NETWORK] Ingress/Service API evolution Time: This is a recurring meeting Meet anytime Join Zoom Meeting https://zoom.us/j/931530074?pwd=SmtZai9UeS9wVGE3azdFWGEwRTVtdz09 Meeting ID: 931 530 074 Password: 621590 One tap mobile +14086380968,,931530074# US (San Jose) +16465588656,,931530074# US (New York) Dial by your location +1 408 638 0968 US (San Jose) +1 646 558 8656 US (New York) Meeting ID: 931 530 074 Find your local number: https://zoom.us/u/abdiTq5bx Meeting notes Date January 2, 2020 (4:30 PM PT) meeting notes (recording to be uploaded) December 19, 2019 (10:30 AM PT) meeting notes ( recording ) November, 2019 Kubecon 2019 San Diego: API evolution design discussion November, 2019 SIG-NETWORK: Ingress Evolution Sync May, 2019 Kubecon 2019 Barcelona: SIG-NETWORK discussion (general topics, includes V2) Design docs Title Description API sketch Sketch of the proposed API Presentations, Talks Date Title November, 2019 Kubecon 2019 San Diego: Evolving the Kubernetes Ingress APIs to GA and Beyond slides , video November, 2019 Kubecon 2019 San Diego: SIG-NETWORK Service/Ingress Evolution Discussion slides May, 2019 Kubecon 2019 Barcelona: Ingress V2 and Multicluster Services slides , video March, 2018 SIG-NETWORK: Ingress user survey data , slides Code of conduct Participation in the Kubernetes community is governed by the Kubernetes Code of Conduct","title":"How to contribute"},{"location":"community/#how-to-contribute","text":"This page contains links to all of the meeting notes, design docs and related discussions around the APIs.","title":"How to contribute"},{"location":"community/#communications","text":"Major discussions and notifications will be sent on the SIG-NETWORK mailing list . We also have a Slack channel (sig-network-service-apis) on k8s.io for day-to-day questions, discussions.","title":"Communications"},{"location":"community/#meetings","text":"Meetings discussing the evolution of the service APIs will alternate times to accommodate participants from various time zones: Thursday 10:30 AM Pacific ( calendar link ) Thursday 4:30 (16:30) PM Pacific ( calendar link )","title":"Meetings"},{"location":"community/#video-conferencing","text":"Meeting link Topic: [SIG-NETWORK] Ingress/Service API evolution Time: This is a recurring meeting Meet anytime Join Zoom Meeting https://zoom.us/j/931530074?pwd=SmtZai9UeS9wVGE3azdFWGEwRTVtdz09 Meeting ID: 931 530 074 Password: 621590 One tap mobile +14086380968,,931530074# US (San Jose) +16465588656,,931530074# US (New York) Dial by your location +1 408 638 0968 US (San Jose) +1 646 558 8656 US (New York) Meeting ID: 931 530 074 Find your local number: https://zoom.us/u/abdiTq5bx","title":"Video conferencing"},{"location":"community/#meeting-notes","text":"Date January 2, 2020 (4:30 PM PT) meeting notes (recording to be uploaded) December 19, 2019 (10:30 AM PT) meeting notes ( recording ) November, 2019 Kubecon 2019 San Diego: API evolution design discussion November, 2019 SIG-NETWORK: Ingress Evolution Sync May, 2019 Kubecon 2019 Barcelona: SIG-NETWORK discussion (general topics, includes V2)","title":"Meeting notes"},{"location":"community/#design-docs","text":"Title Description API sketch Sketch of the proposed API","title":"Design docs"},{"location":"community/#presentations-talks","text":"Date Title November, 2019 Kubecon 2019 San Diego: Evolving the Kubernetes Ingress APIs to GA and Beyond slides , video November, 2019 Kubecon 2019 San Diego: SIG-NETWORK Service/Ingress Evolution Discussion slides May, 2019 Kubecon 2019 Barcelona: Ingress V2 and Multicluster Services slides , video March, 2018 SIG-NETWORK: Ingress user survey data , slides","title":"Presentations, Talks"},{"location":"community/#code-of-conduct","text":"Participation in the Kubernetes community is governed by the Kubernetes Code of Conduct","title":"Code of conduct"},{"location":"concepts/","text":"API Concepts This document is a deep dive into the reasoning and design for the API. The content of this document is taken from the API sketch . We will try to keep the two documents in sync as the sketch document has to lowest bar to contribution, but this document is easier to format well and review. Roles and personas In the original design of Kubernetes, the Ingress and Service resources were based on a self-service model of usage; developers who create Services and Ingresses control all aspects of defining and exposing their applications to their users. We have found that the self-service model does not fully capture some of the more complex deployment and team structures that our users are seeing. The Gateway/Routes API will target the following personas: Infrastructure provider : The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider (AWS, Azure, GCP, ...), the PaaS provider in a company. Cluster operator : The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions. Application developer : The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). We expect that each persona will map approximately to a Role in the Kubernetes Role-Based Authentication (RBAC) system and will define resource model responsibility and separation. Depending on the environment, multiple roles can map to the same user. For example, giving the user all of the above role replicates the self-service model. Resource model Note: Resource will initially live in the networking.x-k8s.io API group as Custom Resource Definitions (CRDs). Unqualified resource names will implicitly be assumed to be part of this API group. Our resource model is based around a separation of concerns for a service producer. Each resource is intended to be (mostly) independently-evolvable and self-consistent: A way to group pods (backends) into a set via label selection: Kubernetes core.Service , independent of application-level routing. A way to describe application-level routing: xxxxRoute , e.g. HTTPRoute , TCPRoute independent of traffic access and consumption (e.g. A way to describe traffic access and consumption: Gateway independent of implementation. A way to describe which implementations of traffic access are available: GatewayClass . The combination of GatewayClass , Gateway , xxxxRoute and Service (s) will define an implementable load-balancer. The diagram below illustrates the relationships between the different resources: Design considerations There are some general design guidelines used throughout this API. Single resource consistency The Kubernetes API guarantees consistency only on a single resource level. There are a couple of consequences for complex resource graphs as opposed to single resources: Error checking of properties spanning multiple resource will be asynchronous. Simple syntax checks will be possible at the single resource level, but cross resource dependencies will need to be handled by the controller. Controllers will need to handle broken links between resources and/or mismatched configuration. Conflicts Separation and delegation of responsibility among independent actors (e.g between cluster ops and application developers) can result in conflicts in the configuration. For example, two application teams may inadvertently submit configuration for the same HTTP path. There are several different strategies for handling this: TODO Extensibility TODO GatewayClass GatewayClass is cluster-scoped resource defined by the infrastructure ops. This resource represents a category of Gateways that can be instantiated. apiVersion: networking.x-k8s.io/v1alpha1 kind: GatewayClass metadata: name: from-internet controller: # links to a custom resource apiGroup: networking.acme.io # that implements this class. kind: cloud-lb name: from-internet A sample controller file: apiVersion: networking.acme.io/v1alpha1 kind: CloudLB metadata: name: from-internet networkTier: auto ipAllocation: auto We expect that one or more GatewayClasses will be created by the infrastructure provider for the user as part of their cloud infrastructure. If the cluster operator wishes to customize their GatewayClasses , they are free to do so, interacting with the custom resource parameters. Example parameters GatewayClass.controller resource will include cluster-level defaults and constraints. The community may converge around a common set of GatewayClass names with well-known meanings (e.g. internet , private ) to ease interoperability between platforms. Gateway A Gateway is 1:1 with the life cycle of the configuration of LB infrastructure. When a user creates a Gateway , a load balancer is provisioned (see below for details) by the GatewayClass controller. Gateway is the resource that triggers actions in this API. Other resources in this API are configuration snippets until a Gateway has been created to link the resources together. The Gateway spec defines the following: GatewayClass used to instantiate this Gateway. Listener bindings, which define addresses and ports, protocol termination, TLS-settings. Listener configuration requested by a Gateway definition can be incompatible with a given GatewayClass (e.g. port/protocol combination is not supported) . In this case, the Gateway will be in an error state, signalled by the status field. Routes, which point to a set of protocol-specific routing served by the Gateway. OPTIONAL: A Gateway can point directly to Kubernetes Service if no advanced routing is required. Deployment models Depending on the GatewayClass , the creation of the Gateway could do any of the following actions: Use cloud APIs to create an LB instance. Spawn a new instance of a software LB (in this or another cluster). Add a configuration stanza to an already instantiated LB to handle the new routes. Program the SDN to implement the configuration. Something else we haven\u2019t thought of yet... The API does not specify which one of these actions will be taken. Note that a GatewayClass controller that manages in-cluster proxy processes MAY restrict Gateway configuration scope, e.g. only be served in the same namespace. Listeners TODO Routes TODO HTTPRoute TODO TCPRoute TODO Generic routing TODO Delegation/inclusion TODO Destinations TODO","title":"API concepts"},{"location":"concepts/#api-concepts","text":"This document is a deep dive into the reasoning and design for the API. The content of this document is taken from the API sketch . We will try to keep the two documents in sync as the sketch document has to lowest bar to contribution, but this document is easier to format well and review.","title":"API Concepts"},{"location":"concepts/#roles-and-personas","text":"In the original design of Kubernetes, the Ingress and Service resources were based on a self-service model of usage; developers who create Services and Ingresses control all aspects of defining and exposing their applications to their users. We have found that the self-service model does not fully capture some of the more complex deployment and team structures that our users are seeing. The Gateway/Routes API will target the following personas: Infrastructure provider : The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider (AWS, Azure, GCP, ...), the PaaS provider in a company. Cluster operator : The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions. Application developer : The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). We expect that each persona will map approximately to a Role in the Kubernetes Role-Based Authentication (RBAC) system and will define resource model responsibility and separation. Depending on the environment, multiple roles can map to the same user. For example, giving the user all of the above role replicates the self-service model.","title":"Roles and personas"},{"location":"concepts/#resource-model","text":"Note: Resource will initially live in the networking.x-k8s.io API group as Custom Resource Definitions (CRDs). Unqualified resource names will implicitly be assumed to be part of this API group. Our resource model is based around a separation of concerns for a service producer. Each resource is intended to be (mostly) independently-evolvable and self-consistent: A way to group pods (backends) into a set via label selection: Kubernetes core.Service , independent of application-level routing. A way to describe application-level routing: xxxxRoute , e.g. HTTPRoute , TCPRoute independent of traffic access and consumption (e.g. A way to describe traffic access and consumption: Gateway independent of implementation. A way to describe which implementations of traffic access are available: GatewayClass . The combination of GatewayClass , Gateway , xxxxRoute and Service (s) will define an implementable load-balancer. The diagram below illustrates the relationships between the different resources:","title":"Resource model"},{"location":"concepts/#design-considerations","text":"There are some general design guidelines used throughout this API.","title":"Design considerations"},{"location":"concepts/#single-resource-consistency","text":"The Kubernetes API guarantees consistency only on a single resource level. There are a couple of consequences for complex resource graphs as opposed to single resources: Error checking of properties spanning multiple resource will be asynchronous. Simple syntax checks will be possible at the single resource level, but cross resource dependencies will need to be handled by the controller. Controllers will need to handle broken links between resources and/or mismatched configuration.","title":"Single resource consistency"},{"location":"concepts/#conflicts","text":"Separation and delegation of responsibility among independent actors (e.g between cluster ops and application developers) can result in conflicts in the configuration. For example, two application teams may inadvertently submit configuration for the same HTTP path. There are several different strategies for handling this: TODO","title":"Conflicts"},{"location":"concepts/#extensibility","text":"TODO","title":"Extensibility"},{"location":"concepts/#gatewayclass","text":"GatewayClass is cluster-scoped resource defined by the infrastructure ops. This resource represents a category of Gateways that can be instantiated. apiVersion: networking.x-k8s.io/v1alpha1 kind: GatewayClass metadata: name: from-internet controller: # links to a custom resource apiGroup: networking.acme.io # that implements this class. kind: cloud-lb name: from-internet A sample controller file: apiVersion: networking.acme.io/v1alpha1 kind: CloudLB metadata: name: from-internet networkTier: auto ipAllocation: auto We expect that one or more GatewayClasses will be created by the infrastructure provider for the user as part of their cloud infrastructure. If the cluster operator wishes to customize their GatewayClasses , they are free to do so, interacting with the custom resource parameters. Example parameters GatewayClass.controller resource will include cluster-level defaults and constraints. The community may converge around a common set of GatewayClass names with well-known meanings (e.g. internet , private ) to ease interoperability between platforms.","title":"GatewayClass"},{"location":"concepts/#gateway","text":"A Gateway is 1:1 with the life cycle of the configuration of LB infrastructure. When a user creates a Gateway , a load balancer is provisioned (see below for details) by the GatewayClass controller. Gateway is the resource that triggers actions in this API. Other resources in this API are configuration snippets until a Gateway has been created to link the resources together. The Gateway spec defines the following: GatewayClass used to instantiate this Gateway. Listener bindings, which define addresses and ports, protocol termination, TLS-settings. Listener configuration requested by a Gateway definition can be incompatible with a given GatewayClass (e.g. port/protocol combination is not supported) . In this case, the Gateway will be in an error state, signalled by the status field. Routes, which point to a set of protocol-specific routing served by the Gateway. OPTIONAL: A Gateway can point directly to Kubernetes Service if no advanced routing is required.","title":"Gateway"},{"location":"concepts/#deployment-models","text":"Depending on the GatewayClass , the creation of the Gateway could do any of the following actions: Use cloud APIs to create an LB instance. Spawn a new instance of a software LB (in this or another cluster). Add a configuration stanza to an already instantiated LB to handle the new routes. Program the SDN to implement the configuration. Something else we haven\u2019t thought of yet... The API does not specify which one of these actions will be taken. Note that a GatewayClass controller that manages in-cluster proxy processes MAY restrict Gateway configuration scope, e.g. only be served in the same namespace.","title":"Deployment models"},{"location":"concepts/#listeners","text":"TODO","title":"Listeners"},{"location":"concepts/#routes","text":"TODO","title":"Routes"},{"location":"concepts/#httproute","text":"TODO","title":"HTTPRoute"},{"location":"concepts/#tcproute","text":"TODO","title":"TCPRoute"},{"location":"concepts/#generic-routing","text":"TODO","title":"Generic routing"},{"location":"concepts/#delegationinclusion","text":"TODO","title":"Delegation/inclusion"},{"location":"concepts/#destinations","text":"TODO","title":"Destinations"},{"location":"cookbook/","text":"API Cookbook TODO: Cookbook will be a page w/ examples for common tasks (exposing an HTTP service, configuring TLS, etc).","title":"API cookbook"},{"location":"cookbook/#api-cookbook","text":"TODO: Cookbook will be a page w/ examples for common tasks (exposing an HTTP service, configuring TLS, etc).","title":"API Cookbook"},{"location":"devguide/","text":"Building, testing and deploying You will need to have Docker installed to perform the steps below. Project management We are using the Github issues and project dashboard to manage the list of TODOs for this project: Open issues Project dashboard Issues labeled good first issue and help wanted are especially good for a first contribution. Release cadence During the development phase, we expect to release on a monthly cadence. We are explicitly decoupling ourselves from the Kubernetes API versioning cycle to give us more flexibility to evolve the specification. As the specification solidifies, we will slow down our release cycle. General target timeline: 1H 2020: Monthly release cycle, with first release targeted for January 31 2H 2020: Slower release cycle Building the code The project uses make to drive the build. You can kick off an overall build from the top-level makefile: make Testing the code The easiest way to test the code is to use the kubebuilder created CRD with a kind cluster. Follow the installation instructions for kind in the README in the repo. kind create cluster ... # Install the CRDs make -f kubebuilder.mk install # Remove the CRDs and associated CRs ./hack/delete-crds.sh Submitting a review TODO Verify Make sure you run the static analysis over the repo before submitting your changes. The Prow presubmit will not let your change merge if verification fails. ./hack/verify-all.sh Documentation The site documentation is written in mkdocs format. The files are contained in docs-src/ . Generated files are in docs/ and published to Github Pages. Building the docs: make -f docs.mk Live preview for editing (view on http://localhost:8000 , CTRL-C to quit): make -f docs.mk serve Publishing The docs are published automatically to Github pages . When making changes to the documentation, generate the new documentation and make the generated code a self-contained commit (e.g. the changes to docs/ ). This will keep the code reviews simple and clearly delineate user vs generated content.","title":"Developer guide"},{"location":"devguide/#building-testing-and-deploying","text":"You will need to have Docker installed to perform the steps below.","title":"Building, testing and deploying"},{"location":"devguide/#project-management","text":"We are using the Github issues and project dashboard to manage the list of TODOs for this project: Open issues Project dashboard Issues labeled good first issue and help wanted are especially good for a first contribution.","title":"Project management"},{"location":"devguide/#release-cadence","text":"During the development phase, we expect to release on a monthly cadence. We are explicitly decoupling ourselves from the Kubernetes API versioning cycle to give us more flexibility to evolve the specification. As the specification solidifies, we will slow down our release cycle. General target timeline: 1H 2020: Monthly release cycle, with first release targeted for January 31 2H 2020: Slower release cycle","title":"Release cadence"},{"location":"devguide/#building-the-code","text":"The project uses make to drive the build. You can kick off an overall build from the top-level makefile: make","title":"Building the code"},{"location":"devguide/#testing-the-code","text":"The easiest way to test the code is to use the kubebuilder created CRD with a kind cluster. Follow the installation instructions for kind in the README in the repo. kind create cluster ... # Install the CRDs make -f kubebuilder.mk install # Remove the CRDs and associated CRs ./hack/delete-crds.sh","title":"Testing the code"},{"location":"devguide/#submitting-a-review","text":"TODO","title":"Submitting a review"},{"location":"devguide/#verify","text":"Make sure you run the static analysis over the repo before submitting your changes. The Prow presubmit will not let your change merge if verification fails. ./hack/verify-all.sh","title":"Verify"},{"location":"devguide/#documentation","text":"The site documentation is written in mkdocs format. The files are contained in docs-src/ . Generated files are in docs/ and published to Github Pages. Building the docs: make -f docs.mk Live preview for editing (view on http://localhost:8000 , CTRL-C to quit): make -f docs.mk serve","title":"Documentation"},{"location":"devguide/#publishing","text":"The docs are published automatically to Github pages . When making changes to the documentation, generate the new documentation and make the generated code a self-contained commit (e.g. the changes to docs/ ). This will keep the code reviews simple and clearly delineate user vs generated content.","title":"Publishing"},{"location":"feedback/","text":"Feedback Use cases, user stories We are currently collecting use case and user stories on this shared Google Doc as this is the lowest barrier to entry. When things stabilize, we will take the contents of the doc and publish it here as individual pages in the repo. Bug reports Bug reports should be filed as Github Issues on this repo. Be sure to use the following template: TODO","title":"Feedback"},{"location":"feedback/#feedback","text":"","title":"Feedback"},{"location":"feedback/#use-cases-user-stories","text":"We are currently collecting use case and user stories on this shared Google Doc as this is the lowest barrier to entry. When things stabilize, we will take the contents of the doc and publish it here as individual pages in the repo.","title":"Use cases, user stories"},{"location":"feedback/#bug-reports","text":"Bug reports should be filed as Github Issues on this repo. Be sure to use the following template: TODO","title":"Bug reports"},{"location":"spec/","text":"API specification TODO","title":"API specification"},{"location":"spec/#api-specification","text":"TODO","title":"API specification"},{"location":"userguide/","text":"API user guide TODO","title":"User guide"},{"location":"userguide/#api-user-guide","text":"TODO","title":"API user guide"}]}
/*

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package k8s.io.service_apis.api.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";
import "sigs.k8s.io/controller-runtime/pkg/scheme/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

// Gateway represents an instantiation of a service-traffic handling infrastructure.
message Gateway {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  optional GatewaySpec spec = 3;

  optional GatewayStatus status = 4;
}

// GatewayClass describes a class of Gateways available to the user
// for creating Gateway resources.
//
// GatewayClass is a Cluster level resource.
//
// Support: Core.
message GatewayClass {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 4;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec for this GatewayClass.
  optional GatewayClassSpec spec = 2;

  // Status of the GatewayClass.
  optional GatewayClassStatus status = 3;
}

// GatewayClassCondition contains the details for the current
// condition of this GatewayClass.
//
// Support: Core, unless otherwise specified.
message GatewayClassCondition {
  // Type of this condition.
  optional string type = 1;

  // Status of this condition.
  optional string status = 2;

  // Reason is a machine consumable string for the last
  // transition. It should be a one-word, CamelCase
  // string. Reason will be defined by the controller.
  //
  // Support: Custom; values will be controller-specific.
  //
  // +optional
  optional string reason = 3;

  // Message is a human readable reason for last transition.
  //
  // +optional
  optional string message = 4;

  // LastTransitionTime is the time of the last change to this condition.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 5;
}

// GatewayClassList contains a list of GatewayClass
message GatewayClassList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 3;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated GatewayClass items = 2;
}

// GatewayClassSpec reflects the configuration of a class of Gateways.
message GatewayClassSpec {
  // Controller is a domain/path string that indicates the
  // controller that managing Gateways of this class.
  //
  // Example: "acme.io/gateway-controller".
  //
  // This field is not mutable and cannot be empty.
  //
  // The format of this field is DOMAIN "/" PATH, where DOMAIN
  // and PATH are valid Kubernetes names
  // (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
  //
  // Support: Core
  //
  // +required
  optional string controller = 1;

  // ParametersRef is a controller specific resource containing
  // the configuration parameters corresponding to this
  // class. This is optional if the controller does not require
  // any additional configuration.
  //
  // Valid resources for reference are up to the Controller. Examples
  // include "configmap" (using the empty string to indicate the core API
  // group) or a custom resource (CRD).
  //
  // Support: Custom
  //
  // +optional
  // +protobuf=false
  optional LocalObjectReference parametersRef = 2;
}

// GatewayClassStatus is the current status for the GatewayClass.
//
// +kubebuilder:subresource:status
message GatewayClassStatus {
  // Conditions is the current status from the controller for
  // this GatewayClass.
  repeated GatewayClassCondition conditions = 1;
}

// GatewayCondition is an error status for a given route.
message GatewayCondition {
  // Type indicates the type of condition.
  optional string type = 1;

  // Status describes the current state of this condition. Can be "True",
  // "False", or "Unknown".
  optional string status = 2;

  // Message is a human-understandable message describing the condition.
  // +optional
  optional string message = 3;

  // Reason indicates why the condition is in this state.
  // +optional
  optional string reason = 4;

  // LastTransitionTime indicates the last time this condition changed.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 5;
}

// GatewayList contains a list of Gateway
message GatewayList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  repeated Gateway items = 3;
}

// GatewayObjectReference identifies a Gateway object.
message GatewayObjectReference {
  // Namespace is the namespace of the referent.
  // +optional
  optional string namespace = 1;

  // Name is the name of the referent.
  //
  // +kubebuilder:validation:Required
  // +required
  optional string name = 2;
}

// GatewaySpec defines the desired state of Gateway.
//
// The Spec is split into two major pieces: listeners describing
// client-facing properties and routes that describe application-level
// routing.
//
// Not all possible combinations of options specified in the Spec are
// valid. Some invalid configurations can be caught synchronously via a
// webhook, but there are many cases that will require asynchronous
// signaling via the GatewayStatus block.
message GatewaySpec {
  // Class used for this Gateway. This is the name of a GatewayClass resource.
  optional string class = 1;

  // Listeners associated with this Gateway. Listeners define what addresses,
  // ports, protocols are bound on this Gateway.
  repeated Listener listeners = 2;

  // Servers binds virtual servers that are hosted by the gateway
  // to listeners.
  //
  // An implementation must validate that Dedicated listeners have no
  // more than 1 server binding.
  //
  // An implementation must validate that all the servers bound to the
  // same combined listener have a compatible discriminator.
  // TODO(jpeach): describe consequences of this validating failing.
  repeated VirtualServerBinding virtualServers = 3;
}

// GatewayStatus defines the observed state of Gateway.
message GatewayStatus {
  // Conditions describe the current conditions of the Gateway.
  repeated GatewayCondition conditions = 1;

  // Listeners provide status for each listener defined in the Spec. The name
  // in ListenerStatus refers to the corresponding Listener of the same name.
  repeated ListenerStatus listeners = 2;
}

// HTTPHeaderFilter defines the filter behavior for a request match.
message HTTPHeaderFilter {
  // Add adds the given header (name, value) to the request
  // before the action.
  //
  // Input:
  //   GET /foo HTTP/1.1
  //
  // Config:
  //   add: {"my-header": "foo"}
  //
  // Output:
  //   GET /foo HTTP/1.1
  //   my-header: foo
  //
  // Support: extended?
  //
  // +optional
  map<string, string> add = 1;

  // Remove the given header(s) on the HTTP request before the
  // action. The value of RemoveHeader is a list of HTTP header
  // names. Note that the header names are case-insensitive
  // [RFC-2616 4.2].
  //
  // Input:
  //   GET /foo HTTP/1.1
  //   My-Header1: ABC
  //   My-Header2: DEF
  //   My-Header2: GHI
  //
  // Config:
  //   remove: ["my-header1", "my-header3"]
  //
  // Output:
  //   GET /foo HTTP/1.1
  //   My-Header2: DEF
  //
  // Support: extended?
  //
  // +optional
  repeated string remove = 2;
}

// Listener defines a
message Listener {
  // Type specifies the server binding semantics of this listener.
  //
  // +required
  optional string type = 1;

  // Name is the listener's name and should be specified as an
  // RFC 1035 DNS_LABEL [1]:
  //
  // [1] https://tools.ietf.org/html/rfc1035
  //
  // Each listener of a Gateway must have a unique name. Name is used
  // for associating a listener in Gateway status.
  //
  // Support: Core
  //
  // +required
  optional string name = 2;

  // Address requested for this listener. This is optional and behavior
  // can depend on GatewayClass. If a value is set in the spec and
  // the request address is invalid, the GatewayClass MUST indicate
  // this in the associated entry in GatewayStatus.Listeners.
  //
  // Support:
  //
  // +optional
  optional ListenerAddress address = 3;

  // Port is a list of ports associated with the Address.
  //
  // Support:
  // +optional
  optional int32 port = 4;

  // Protocol is the protocol used by the listener, either TCP or UDP.
  //
  // Defaults to TCP.
  //
  // Support: Core
  //
  // +optional
  optional string protocol = 5;

  // Extension for this Listener.  The resource may be "configmap" (use
  // the empty string for the group) or an implementation-defined resource
  // (for example, resource "mylistener" in group "networking.acme.io").
  //
  // Support: custom.
  // +optional
  optional LocalObjectReference extension = 6;
}

// ListenerAddress describes an address for the Listener.
message ListenerAddress {
  // Type of the Address. This is one of the *AddressType constants.
  //
  // Support: Extended
  optional string type = 1;

  // Value. Examples: "1.2.3.4", "128::1", "my-ip-address". Validity of the
  // values will depend on `Type` and support by the controller.
  optional string value = 2;
}

// ListenerCondition is an error status for a given listener.
message ListenerCondition {
  // Type indicates the type of condition.
  optional string type = 1;

  // Status describes the current state of this condition. Can be "True",
  // "False", or "Unknown".
  optional string status = 2;

  // Message is a human-understandable message describing the condition.
  // +optional
  optional string message = 3;

  // Reason indicates why the condition is in this state.
  // +optional
  optional string reason = 4;

  // LastTransitionTime indicates the last time this condition changed.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 5;
}

// ListenerStatus is the status associated with each listener block.
message ListenerStatus {
  // Name is the name of the listener this status refers to.
  optional string name = 1;

  // Address bound on this listener.
  optional ListenerAddress address = 2;

  // Conditions describe the current condition of this listener.
  repeated ListenerCondition conditions = 3;
}

// VirtualServerObjectReference identifies a virtual server object in the same
// namespace as the Gateway.
//
// +k8s:deepcopy-gen=false
message LocalObjectReference {
  // Group is the group of the referent.  The empty string represents
  // the core API group.
  //
  // +kubebuilder:validation:Required
  // +required
  optional string group = 1;

  // Resource is the resource of the referent.
  //
  // +kubebuilder:validation:Required
  // +required
  optional string resource = 2;

  // Name is the name of the referent.
  //
  // +kubebuilder:validation:Required
  // +required
  optional string name = 3;
}

// TLSConfig describes the TLS configuration for a party in a TLS
// session.
//
// References
// - nginx: https://nginx.org/en/docs/http/configuring_https_servers.html
// - envoy: https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto
// - haproxy: https://www.haproxy.com/documentation/aloha/9-5/traffic-management/lb-layer7/tls/
// - gcp: https://cloud.google.com/load-balancing/docs/use-ssl-policies#creating_an_ssl_policy_with_a_custom_profile
// - aws: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies
// - azure: https://docs.microsoft.com/en-us/azure/app-service/configure-ssl-bindings#enforce-tls-1112
message TLSConfig {
  // ALPNProtocols is the list of IANA-registered ALPN protocol names
  // that this TLS party is willing to accept.
  //
  // https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
  //
  // TODO: If unset, defaults to?
  //
  // Support: Core
  //
  // +optional
  repeated string alpnProtocols = 1;

  // Certificates is a list of references to Kubernetes objects that each
  // contain an identity certificate that is bound to the listener.  The
  // host name in a TLS SNI client hello message is used for certificate
  // matching and route host name selection.  The SNI server_name must
  // match a route host name for the Gateway to route the TLS request.  If
  // an entry in this list specifies the empty string for both the group
  // and the resource, the resource defaults to "secret".  An
  // implementation may support other resources (for example, resource
  // "mycertificate" in group "networking.acme.io").
  //
  // Support: Core (Kubernetes Secrets)
  // Support: Implementation-specific (Other resource types)
  //
  // +required
  repeated LocalObjectReference certificates = 2;

  // MinimumVersion of TLS allowed. It is recommended to use one of
  // the TLS_* constants above. Note: this is not strongly
  // typed to allow implementation-specific versions to be used without
  // requiring updates to the API types. String must be of the form
  // "<protocol><major>_<minor>".
  //
  // Support: Core for TLS1_{1,2,3}. Implementation-specific for all other
  // values.
  //
  // +optional
  optional string minimumVersion = 3;

  // Options are a list of key/value pairs to give extended options
  // to the provider.
  //
  // There variation among providers as to how ciphersuites are
  // expressed. If there is a common subset for expressing ciphers
  // then it will make sense to loft that as a core API
  // construct.
  //
  // Support: Implementation-specific.
  //
  // +optional
  map<string, string> options = 4;
}

// TcpRoute is the Schema for the tcproutes API
message TcpRoute {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  optional TcpRouteSpec spec = 3;

  optional TcpRouteStatus status = 4;
}

// TcpRouteList contains a list of TcpRoute
message TcpRouteList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  repeated TcpRoute items = 3;
}

// TcpRouteSpec defines the desired state of TcpRoute
message TcpRouteSpec {
}

// TcpRouteStatus defines the observed state of TcpRoute
message TcpRouteStatus {
}

// TrafficSplit is the Schema for the trafficsplits API
message TrafficSplit {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  optional TrafficSplitSpec spec = 3;

  optional TrafficSplitStatus status = 4;
}

// TrafficSplitList contains a list of TrafficSplit
message TrafficSplitList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  repeated TrafficSplit items = 3;
}

// TrafficSplitSpec defines the desired state of TrafficSplit
message TrafficSplitSpec {
}

// TrafficSplitStatus defines the observed state of TrafficSplit
message TrafficSplitStatus {
}

// VirtualServer is the Schema for the virtualservers API.
message VirtualServer {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 2;

  optional VirtualServerSpec spec = 3;

  optional VirtualServerStatus status = 4;
}

// VirtualServerAction is the action taken given a match.
message VirtualServerAction {
  // ForwardTo sends requests to the referenced object.  The resource may
  // be "service" (use the empty string for the group), or an
  // implementation may support other resources (for example, resource
  // "my-virtualserver-target" in group "networking.acme.io").
  //
  // Support: Core
  //
  // +optional
  optional LocalObjectReference forwardTo = 1;

  // Extension is an optional, implementation-specific extension to the
  // "action" behavior.  The resource may be "configmap" (use the empty
  // string for the group) or an implementation-defined resource (for
  // example, resource "my-virtualserver-action" in group "networking.acme.io").
  //
  // Support: custom
  //
  // +optional
  optional LocalObjectReference extension = 2;
}

// VirtualServerBinding specifies which listener a virtual server should
// be attached to. A server can be bound to 1 or more listeners.
message VirtualServerBinding {
  // ListenerName is the unique name of a listener.
  //
  // TODO(jpeach): We could let an empty name mean all listeners, but
  // there are trade-offs to that. For now this field must not be empty.
  //
  // +required
  optional string listenerName = 1;

  // VirtualServer is a reference to the virtual server to be attached.
  //
  // +required
  optional LocalObjectReference virtualServer = 2;
}

// VirtualServerFilter defines a filter-like action to be applied to
// requests.
message VirtualServerFilter {
  // Headers related filters.
  //
  // Support: extended
  // +optional
  optional HTTPHeaderFilter headers = 1;

  // Extension is an optional, implementation-specific extension to the
  // "filter" behavior.  The resource may be "configmap" (use the empty
  // string for the group) or an implementation-defined resource (for
  // example, resource "myroutefilter" in group "networking.acme.io").
  //
  // Support: custom
  //
  // +optional
  optional LocalObjectReference extension = 2;
}

// VirtualServerList contains a list of VirtualServer.
message VirtualServerList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta typeMeta = 1;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 2;

  repeated VirtualServer items = 3;
}

// VirtualServerMatch defines the predicate used to match requests to a
// VirtualServer.
message VirtualServerMatch {
  // PathType is defines the semantics of the `Path` matcher.
  //
  // Support: core (Exact, Prefix)
  // Support: extended (RegularExpression)
  // Support: custom (ImplementationSpecific)
  //
  // Default: "Exact"
  //
  // +optional
  optional string pathType = 1;

  // Path is the value of the HTTP path as interpreted via
  // PathType.
  //
  // Default: "/"
  //
  // Support: ?
  //
  // +optional
  optional string path = 2;

  // HeaderType defines the semantics of the `Header` matcher.
  //
  // Support: ?
  //
  // +optional
  optional string headerType = 3;

  // Header are the Header matches as interpreted via
  // HeaderType.
  //
  // Support: ?
  //
  // +optional
  map<string, string> header = 4;

  // Extension is an optional, implementation-specific extension to the
  // "match" behavior.  The resource may be "configmap" (use the empty
  // string for the group) or an implementation-defined resource (for
  // example, resource "myroutematcher" in group "networking.acme.io").
  //
  // Support: custom
  //
  // +optional
  optional LocalObjectReference extension = 5;
}

// VirtualServerRule is a rule to match, filter and perform actions on requests
// to a VirtualServer.
message VirtualServerRule {
  // Match defines criteria for matching a request.
  //
  // Support: Core
  //
  // +required
  optional VirtualServerMatch match = 1;

  // Filter defines what filters are applied to the request.
  //
  // Support: Core
  //
  // +optional
  optional VirtualServerFilter filter = 2;

  // Action defines what happens to the request.
  //
  // Support: Core
  //
  // +required
  optional VirtualServerAction action = 3;
}

// VirtualServerSpec defines the desired state of VirtualServer.
message VirtualServerSpec {
  // Hostnames are the set of domain name that refers to this
  // HTTPServer. These names must be unique across the Listener.
  //
  // Support: Core
  //
  // +required
  repeated string hostnames = 1;

  // TLS is the TLS configuration used for the VirtualServer. If this host has
  // multiple names, each name should be present in the server certificate as
  // a DNS SAN.
  //
  // The ALPNProtocols field in this TLSConfig must contain only valid
  // HTTP protocol identifiers, i.e. "http/0.9", "http/1.0", "http/1.1",
  // "h2". Implementations may accept only a subset of these values if
  // the underlying proxy implementation does not implement the
  // corresponding HTTP protocol version.
  //
  // Support: Core
  //
  // +optional
  optional TLSConfig tls = 2;

  // Rules are rules to match, filter and perform actions on requests.
  //
  // Support: Core
  //
  // +required
  repeated VirtualServerRule rules = 3;

  // Extension is an optional, implementation-specific extension to the
  // "host" block.  The resource may be "configmap" (use the empty string
  // for the group) or an implementation-defined resource (for example,
  // resource "myroutehost" in group "networking.acme.io").
  //
  // Support: Custom
  //
  // +optional
  optional LocalObjectReference extension = 4;
}

// VirtualServerStatus defines the observed state of VirtualServer.
message VirtualServerStatus {
  repeated GatewayObjectReference gateways = 1;
}

